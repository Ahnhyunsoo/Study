하늘은 큐브를 만든다.
카메라는 큐브안에 존재한다.

큐브를 그리려면 정점의 구조체가 다르다.
큐브 구조체는
UV좌표를 vector2가아닌 vector3로 갖게한다.
큐브의 UV좌표 정점은 큐브의 중점을 기준으로 어디있는지 정의하게 만들어져있다. 중점을 기준으로 방향벡터로 판단한다.
큐브의 로컬기준으로 방향벡터를 지정한다. 빼는 중점이 원점이기 때문에 빼는게 의미가 없기 때문에 그냥 대입한다.
포지션look받아올 때 _float3로 형변환 

D3DRS_ZENABLE, FLASE = 깊이비교를 하지 않고 그리겠다.

D3DRS_ZWRITEENABLE, FLASE = 깊이기록을 안한다.

큐브에 각기다른 이미지를 붙여주는방법

1. 각기다른 네모를 그려서 붙여준다 단점 = 중복정점이많아진다.

2. 큐브로 그려준다. 텍스처6장의 이미지를 1장에 매핑한다.

파일핸들 생성후 ReadFile을 하고 Close를 안하고 다시 ReadFile을 하면 읽었던부분에서 이어서 읽는다.

지형타기 = 선형보간 , 평면 방정식 2가지가 있다.
근데 3D에선 평면 방정식이 쉽고 유용하다.

ax+by+cz+d = 0 을 만족하는 xyz점

평면에 수직인 벡터끼리 비교했을 때 방향벡터를 비교한다. 방향벡터가 같으면 기울기가 같은것이다.

평면에 수직인 벡터와 평면에 존재하는 점 두개의 데이터가 있으면 평면을 구분지을 수 있다.

a  b  c 는 각각 평면에 수직인 벡터의 성분을 표현한다.
a는 수직인벡터의 x성분 b는 y성분 c는 z성분
xyz = 평면위에 존재하는 점의 벡터이다.

함수를 이용해서 평면방정식을 구할 수 있다.

지형타기를 위해 지형상의 어떤 삼각형위에 있는가를 구한다.

그리고 그 삼각형의 세 점을 이용하여 법선벡터를 구하고 이세점중 하나만 넣어서
이 삼각형의 평면을 구한다.

저 식에 플레이어xz를 넣고 평면방정식을 이용해서 성분을 넣어주면 
y가 나오는데 이 y가 플레이어가 평면에 서있어야할 y값이다.

문제는 어느 삼각형 위에 존재하느냐를 체크해줘야한다.

플레이어의 포지션 x와 z를 구한 후
x*타일사이즈x(인트형변환) * 타일갯수 + z도마찬가지 하면 좌측 하단의 정점인덱스가 나온다.
렉트정점의 인덱스는 구했다. 하지만 어느삼각형에 있는지를 구해야한다.
왼쪽정점에 플레이어x를 빼고  왼쪽정점에서 플레이어z를 빼고 구한결과로 x와z크기비교해서 x가 크면 오른쪽위 z가 크면 왼쪽아래 삼각형에 존재한다.
정점의 인덱스를 알고있으니 정점에 접근해서 해당 정점에 수직인 법선벡터를 구한다.

평면상의 점 3개를 주면 알아서 외적해서 법선벡터를 구해준다.
인덱스를 알고있기 때문에 해당인덱스에 해당하는 정점의 포지션을 인자로 넣어주면 된다.
D#DXPlaneFromPoints(저장할평면인자, 점, 점, 점)

Plane 구했다.
때문에 Plane의 요소와 플레이어의 요소를 넣어주면 된다.
y = (-ax - cz - d) / b 

인덱스의 포지션을 받으려면 락언락해야해서 느리다. 때문에 메모리를 미리 할당해주자.

터레인에 VTXTEX* m_Vertexes 선언하고

정점의 위치를 대입해줄 때 이중대입을 해서 저장해준다.

받아놓은 float3 딜리트해주면 사본에서 삭제한걸 원본에서 삭제하기 때문에 댕글리가 터진다. 때문에 불변수 하나 추가해서
사본을 만들 땐 true로 해주고 원본일 땐 false로 해줘서 조건문으로 false일 때 삭제하면 된다.

