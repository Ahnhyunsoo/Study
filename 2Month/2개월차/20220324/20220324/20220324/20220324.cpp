// 20220324.cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.
//

#include "stdafx.h"

//재귀 함수의 경우 반환 타입 도는 매개 변수에 const와 &를 붙이게 되면 값 변경이 불가능하기 때문에 문제가 발생한다.


/*
상수 = 선언과 동시에 초기화를 해야한다.
*/
class CObj
{
private:
	const int m_iA;



public:
	void Render(void) { cout << m_iA << endl; }


public:
	CObj() : m_iA(10) // 이니셜라이저를 이용한 초기화 기법
	{
		//m_iA = 10; // 생성된 메모리에 대입을 통한 초기화 
					//쓰레기값인 상수에 값을 대입하는행위
		//맴버변수도 이니셜라이저로 초기화를 할 수 있다. 대입보단 속도가 훨신 빠르다..
		//이니셜라이저를 통한 초기화는 하나씩만 가능하다.
		//구조체나 배열같은 여러개의 자료는 불가능하다. 내부에서 memset으로 초기화 해줘야한다.
		//객체가 생성될 때 생성자가 호출되고 메모리에 할당되기때문에 생성자 내에서 이니셜라이저로 초기화해주면 된다.
		//쓰기전용 = 값 변경가능 읽기전용 = 값변경 불가
		//const가 붙으면 읽기전용으로 사용하겠다. 함수뒤에 const를 붙여주면 읽기전용 함수가 된다.
		//const함수는 읽기전용 이므로 값변경같은 행위가 불가능하다.
		//읽기전용 함수안에서 함수를 호출하고싶을 땐 같은 읽기전용함수만 호출가능하다. 
		//호출한 함수가 쓰기전용 함수가 온다면 데이터 변경 가능성이 있기 때문에 컴파일러가 허용하지 않는다.
		//선언부와 정의부 둘다 const를 붙혀야 한다.
		//const가 붙고 안붙고에 따라서 오버로딩이 성립할 수 있다.
		//const붙은 객체가 const붙은 함수를 호출할 수 있도록 오버로딩이 성립된다.
		//return해주면 값이 복사된다. 그 메모리 공간이 넘어가는게 아니다.
		//그래서 return해줄 때 원본값을 그대로 보내주고싶으면 래퍼런스(&)를 사용한다.
		//원본값을 보내줬을 때 변경해버리며 안되니까 래퍼런스에 const를 붙여주면 된다.
		//인자로 넘겨줄 때도 값이 복사되기 때문에 래퍼런스로 보내주면 원본값을 참조하면된다.
		//매개변수로 상수를 받아서 값변경을 하지 않을 때 읽기전용 매개변수 const &를 사용한다 const라서 값변경 불가능하고 원본 그대로 받아서 값복사가 안일어난다.
		//매개변수로 변수를 받아서 할 때는 그냥래퍼런스로 받으면 된다.
		//클래스의 정적변수를 초기화 하려면 어디클래스의 정적변수인지 알려줘야한다.
		//같은 객체 타입끼리는 STATIC 맴버 변수의 메모리 공간을 공유하여 사용한다.
		//Static 맴버변수는 각 객체의 소유가 아니라는 증거
		//Static변수는 맴버변수로 있다고 해도 클래스의 소유가 아니다. 데이터가 등록된 영역이 다르기 때문


		//Static을 public으로 선언하면 객체생성없이도 접근이 가능하다.

		//Static 맴버함수는 클래스 내에 있는 맴버변수와 맴버함수를 사용할 수 없다.
		
		//일반적인 함수 내 일반적인 지역변수를 사용하는 것은 문제가 되지않는다.

		//데이터의 영역이 다르면 사용할 수 없다.★★★

		//1. static 맴버함수는 static 맴버 변수와 동일한 기능을 가진다.
		//2. static으로 선언된 변수와 함수는 해당 클래스로 생성된 모든 객체가 공유한다. 
		//3. 각 개체의 소유가 아니다
		//4. static 맴버 함수 내부에서 일반적인 맴버 변수, 맴버 함수를 접근할 수 없다.
		//5. namespace를 통해 객체를 생성하지 않고 호출할 수 있다.
		//6. 프로그램 시작 시(컴파일 시점) 메모리가 할당되고 프로그램 종료 시 메모리가 해제된다.
		//7. 할당되는 메모리 공간은 data 영역에 해당한다.


	}
};


int main()
{



    return 0;
} 

