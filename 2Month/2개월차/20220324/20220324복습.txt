20220324 복습

const = 상수화 시키는 문법
static = static으로 선언된 변수는 정적변수이다.	함수밖에 선언하면 외부접근 가능한 정적변수 함수안에 선언하면 내부접근 가능한 정적변수
맴버상수를 초기화 하는 방법 = 이니셜라이저
상수는 선언과 동시에 초기화를 반드시 해줘야하는데 이때 생성자에 이니셜라이저를 사용해 상수를 초기화 할 수 있다.
생성자():상수맴버변수(값){} 이런식으로 사용하면 된다.
CTest(): a(10)
단 하나씩만 초기화 가능하다. 배열이나 구조체같은 여러개의 자료는 한번에 초기화할 수 없다. (구조체나 배열은 내부에서 memset으로 초기화 해줘야한다.)

함수의 인자를 래퍼런스로 넘겨주면 값복사가 일어나지 않아 매우 합리적이다. 대신 const를 붙여야만한다. const가 없으면 원본값을 바꿀 가능성이 있기 때문이다.
함수를 const화 하면 읽기전용 이므로 함수 내에서 쓰기 작업을 하지못한다. (대입이나 연산같은 작업)

const함수 내에선 const함수만 호출가능하다. 일반 함수를 호출하면 값변경의 가능성이 있기 때문이다.
const함수를 사용할 땐 선언부와 정의부 모두 const를 붙여야 한다.
const가 붙고 안붙고에 따라서 오버로딩이 성립될 수 있다.
const붙은 객체가 const붙은 함수를 호출할 수 있도록 오버로딩이 성립된다.

return해주면 값이 복사된다. 그 메모리 공간이 넘어가는게 아니다.
그래서 return해줄 때 원본값을 그대로 보내주고싶으면 래퍼런스(&)를 사용한다.
원본값을 보내줬을 때 변경해버리며 안되니까 래퍼런스에 const를 붙여주면 된다.
인자로 넘겨줄 때도 값이 복사되기 때문에 래퍼런스로 보내주면 원본값을 참조하면된다.
매개변수로 상수를 받아서 값변경을 하지 않을 때 읽기전용 매개변수 const &를 사용한다 const라서 값변경 불가능하고 원본 그대로 받아서 값복사가 안일어난다.
매개변수로 변수를 받아서 할 때는 그냥래퍼런스로 받으면 된다.
클래스의 정적변수를 초기화 하려면 어디클래스의 정적변수인지 알려줘야한다.
같은 객체 타입끼리는 STATIC 맴버 변수의 메모리 공간을 공유하여 사용한다.
Static 맴버변수는 각 객체의 소유가 아니라는 증거
Static변수는 맴버변수로 있다고 해도 클래스의 소유가 아니다. 데이터가 등록된 영역이 다르기 때문

Static을 public으로 선언하면 객체생성없이도 접근이 가능하다.
Static 맴버함수는 클래스 내에 있는 맴버변수와 맴버함수를 사용할 수 없다.
일반적인 함수 내 일반적인 지역변수를 사용하는 것은 문제가 되지않는다.
데이터의 영역이 다르면 사용할 수 없다.★★★

1. static 멤버 함수는 static 멤버 변수와 동일한 기능을 가진다.
2. static으로 선언된 변수와 함수는 해당 클래스로 생성된 모든 객체가 공유한다.
3. 각 객체의 소유가 아니다
4. stiatic 멤버 함수 내부에서 일반적인 멤버 변수, 함수를 접근할 수 없다.
5. namespace를 통해 객체를 생성하지 않고 호출할 수 있다.
6. 프로그램 시작 시(컴파일 시점) 메모리가 할당되고 프로그램 종료 시 메모리가 해제된다.
7. 할당되는 메모리 공간은 data 영역에 해당한다.


