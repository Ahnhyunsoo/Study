// 20220404.cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.
//

#include "stdafx.h"


int main()
{
    return 0;
}



/*
게임에선 커맨드큐를 사용한다. 내가 입력한 값에 따라 스킬이 나간다.
STL = 템플릿을 기반으로 하는 클래스 템플릿을 모아놓은 집함 , 표준 템플릿 라이브러리
C++문법을 기반으로 해서 외부에서 만들어진 라이브러리 
C++에서 제공하는 라이버러리 일종으로 프로그래밍에 필요한 자료구조 및 알고리즘을 제공함
템플릿을 기반으로 하기 때문에 모든 자료형에 호환하므로 일반화 프로그래밍의 한 예로 말할 수 있다.
Standard Template library

STL 구성요소
1. 컨테이너
2. 알고리즘
3. 함수 객체
4. 반복자(이터레이터) *** 중요

*/

#pragma region 컨테이너
/*
컨테이너 : 데이터를 저장한는 객체, 또는 자료 구조가 구현되어 있는 객체
vector, deque, list, set, multiset, map, multimap, string

컨테이너 구분 기준 1. 원소를 어떻게 배치하느냐 2. 메모리를 어떤 형식으로 생성하느냐

원소 배치에 따른 분류
1. 표준 시퀀스 컨테이너 : 선형적 (vector, deque, list)
2. 표준 연관 컨테이너 : 비선형적 (set, multiset, map, multimap) 암기**

메모리 저장 방식에 따른 분류
1. 배열 기반 컨테이너 : vector, deque
2. 노드 기반 컨테이너 : list, set, multiset, map, multimap  암기**

vector 와 리스트는 면접의 단골 보통 둘이 비교해서 물어본다.
map하고 어노드맵 하고 비교하면서 공부해야한다.

컨테이너 어댑터 : 기존 컨테이너의 기능 중 일부 기능만을 사용 가능하며, 기능 제한이나 기능이 변형되어 있는 컨테이너를 말한다.
Queue, stack, priority queue

근사(almost : 거의 근접한) 컨테이너 : string , wstring

*/
#pragma endregion 컨테이너

#pragma region 알고리즘

/*
졸업 후 공부 순서 자료구조 -> c# or 시스템 프로그래밍 -> 알고리즘

STL 알고리즘 : 컨테이너 내에서 정렬, 삭제, 탐색 등을 해결하는 일반화된 방법을 제공하는 함수 템플릿 모음
대부분의 알고리즘 함수 템플릿은 특정 컨테이너의 맴버가 아닌 전역의 형태로 작성되어 있다.
객체에 맴버로 포함하여 캡슐화를 적극적으로 사용하지 않은 이유는 일반화 프로그래밍에서 다수 컨테이너에 대해 보편적으로 
알고리즘 함수 템플릿의 대부분은 <algorithm> 헤더 파일에 존재한다.

*/

#pragma endregion 알고리즘

#pragma region 함수객체

/*
함수 객체 : operator를 오버로딩 해놓은 클래스들을 포함하고 있다. 컴파일 시 알고리즘의 인자값의 형태로 함수 객체를 전달할 수 있다.
함수 객체는 호출 라인을 인라인화하여 일반 함수 홏루보다 빠르다.
*/

#pragma endregion 함수객체

#pragma region 반복자

/*
반복자 : 컨테이너 내의 원소를 순회하여 접근 또는 값 변경을 하기 위한 객체
STL의 핵심이며, 컨테이너마다 데이터 저장 방식 및 메모리 구조가 다르기 때문에 각각 순회 방법을 일반화하기 위해 사용
컨테이너 마다 반복자 객체를 템플릿화하여 만들어 놓았고, 반복자끼리 대입, 비교 연산 등 여러 연산자들 또한 오버로딩이 되어있다.

반개 구간
배열은 항상 0부터 시작임으로 시작부분은 닫혀있고 뒤쪽에 추가하는건 닫혀있지않다.
[begin, end)

*/

#pragma endregion 반복자


/*
시간복잡도  
빅오표기법
복잡도 : 
1. 상수시간 복잡도 : 원소의 개수와 상관없이 일정한 퍼포먼스를 유지한다. 다만 적은 개수여도 초반에 일정 수행시간이 걸린다.(좋고 선호하는 복잡도)
2. 로그시간 복잡도 : 개수 대비 시간이 증가하지만 완만하게 증가한다.
3. 선형 시간 복잡도 : 개수 대비 시간이 증가한다.
4. 지수 시간 복잡도 : 개수가 적으면 속도가 괜찮지만 개수가 많아지면 수행시간이 폭등한다.
*/

#pragma region 백터

/*
1. 배열은 크기를 정해놓고 사용하는 문법이다.
2. 백터 = 기본적으로 동적 배열 기반으로 하는 컨테이너다.
동적 배열 기반이기에 임의 접근(인덱스 접근)이 가능하다. 탐색에 용이하다.
삽입 시에 앞에서 할 수 없으며 맨 끝에서부터 삽입해 나간다.
중간 삽입 및 삭제 시에 삽입 공간 확보, 삭제 공간 활용을 위해 해당 인덱스 이후의
원소 개수만큼 포인터 이동이 발생하기 때문에 느리다. 원소 개수만큼의 선형적 시간 복잡도.
단, 맨 끝에서 삽입 삭제 시에는 상수 시간 복잡도(빠르다는 이야기) 왜냐하면 맨 끝에서는 포인터 이동할 원소들이 없기 때문이다.
동적배열이므로 배열의 크기를 넘어가는 삽입이 발생할 시에 동적 배열의 재 할당 및 현재
원소들의 복사가 일어나기 때문에 느리다.
vector의 원소를 삭제하여도 원소가 존재했던 메모리 공간은 남아있는다.
vector는 삽입 삭제가 용이하지 못하다.
*/



#pragma endregion 백터

#pragma region 리스트

/*
1. 리스트 = 노드를 기반으로 하는 컨테이너이다.
2. 더블 링크드 리스트로 구현된 컨테이너, 즉 클래스 템플릿이다.
3. 앞, 뒤 노드 삽입 삭제가 가능하다.
4. 각 노드는 연속적인메모리 공간에 나열된 것이 아니라 비 연속적인 메모리 공간에 여기
저기 저장되어 있지만 포인터로 각 노드를 연결하여 마치 연속된 공간에 나열한 것처럼 보일 뿐이다.
5. 따라서, 각 노드에 대한 임의 접근(인덱스 접근)이 불가능하다.
6. 임의 접근이 불가능하므로 탐색 시에는 탐색하고자 하는 데이터가 나오기까지 노드가 
저장된 순서대로 순회해야 한다는 점 때문에 탐색 시에는 선형 시간 복잡도가 적용된다. vector보다 불리하다.
7. 노드의 삽입 및 삭제 시에 포인터를 통해 노드의 앞, 뒤를 연결 및 연결 해제를 하기만
하면 되므로 중간 삽입 삭제 시에 연속된 메모리 공간을 쓰는 배열과 달리 메모리 공간을
확보 및 축소하고자 원소들을 밀고 당길 필요가 없다. 상수 시간 복잡도
8. 또한 배열처럼 한정된 메모리 공간을 쓰는 것이 아니기 때문에 사용자가 원하는 만큼
런타임 시에도 계속해서 노드를 추가해 나갈 수 있어 데이터 저장에 있어서 유연하다.
9. 삽입 삭제는 vector보다 용이하다.

*/

#pragma endregion 리스트


/*

백터 
메모리 구조상 배열
단방향 접근
탐색이 빠르고 중간삽입삭제가 힘들다

리스트  
메모리 구조상 노드
양방향 접근
탐색이 느리고 중간삽입삭제가 쉽다

데크 = 더블 엔디드 큐
백터를 보완하기 위해 나온 문법
양쪽다 열려있어서 앞 뒤 모두 삽입삭제가가능하고
상수 시간 복잡도를 갖고있다.
vector의 한종류로 앞에서도 삽입 가능한 기능이 추가되었다.
즉 양 끝에서 삽입 및 삭제가 가능하다. 상수 시간 복잡고
vector처럼 중간 삽입 및 삭제 시에는 선형적 시간이 걸려 느리다. vector보다 느림
vector의 일종으로 임의 접근(인덱스 접근)이 가능하다.
실무 면접에서도 deque보다 vector위주로 물어보니 학원에선 vector를 사용한다.

*/