#include <iostream>

using namespace std;

void main(void)
{
	// STL : 템플릿을 기반으로 하는 클래스 템플릿을 모아놓은 집합, 표준 템플릿 라이브러리
	// C++에서 제공하는 라이브러리의 일조으로 프로그래밍에 필요한 자료구조 및 알고리즘을 클래스 템플릿화 하여 제공
	// 템플릿을 기반으로 하기 때문에 모든 자료형에 호환하므로 반화 프로그래밍의 한 예로 말할 수 있다.


	// STL 구성요소
/*
	1. 컨테이너
	2. 알고리즘
	3. 함수 객체
	4. 반복자(이터레이터)
*/

#pragma region 컨테이너

	// 컨테이너 : 데이터를 저장하는 객체, 또는 자료 구조가 구현되어 있은 객체
	// vector, deque, list, set, multiset, map, multimap, string

	// 컨테이너 구분 기준 1. 원소를 어떻게 배치하느냐	 2. 메모리를 어떤 형식으로 생성하느냐

	/*원소 배치에 따른 분류

	1. 표준 시퀀스 컨테이너 : 선형적, vector, deque, list 
	2. 표준 연관 컨테이너 :  비선형적, set, multiset, map, multimap

	메모리 저장 방식에 따른 분류

	1. 배열 기반 컨테이너 : vector, deque
	2. 노드 기반 컨테이너 : list, set, multiset, map, multimap

	컨테이너 어댑터 : 기존 컨테이너의 기능 중 일부 기능만을 사용 가능하며, 기능 제한이나 기능이 변형되어 있는 컨테이너를 말한다.
	queue, stack, priority queue	

	근사(almost) 컨테이너 : string, wstring*/

#pragma endregion 컨테이너

#pragma region 알고리즘

	// STL 알고리즘 : 컨테이너 내에서 정렬, 삭제, 탐색 등을 해결하는 일반화된 방법을 제공하는 함수 템플릿 모음
	// 대부분의 알고리즘 함수 템플릿은 특정 컨테이너의 멤버가 아닌 전역의 형태로 작성되어 있다.
	// 객체에 멤버로 포함하여 캡슐화를 적극적으로 사용하지 않은 이유는 일반화 프로그래밍에서 다수 컨테이너에 대해 보편적으로 적용할 수 있도록 하기 위함이다.
	// 알고리즘 함수 템플릿의 대부분은 <algorithm> 헤더 파일에 존재한다.

#pragma endregion 알고리즘

#pragma region 함수객체

	// 함수 객체 : operator를 오버로딩 해놓은 클래스들을 포함하고 있다. 컴파일 시 알고리즘의 인자값의 형태로 함수 객체를 전달할 수 있다.
	// 함수 객체는 호출 라인을 인라인화하여 일반 함수 호출보다 빠르다.

#pragma endregion 함수객체

#pragma region 반복자(이터레이터)

/*
	반복자 : 컨테이너 내의 원소를 순회하여 접근 또는 값 변경을 하기 위한 객체
	STL의 핵심이며, 컨테이너마다 데이터 저장 방식 및 메모리 구조가 다르기 때문에 각각 순회 방법을 일반화하기 위해 사용
	컨테이너 마다 반복자 객체를 템플릿화하여 만들어 놓았고, 반복자끼리 대입, 비교 연산 등 여러 연산자들 또한 오버로딩이 되어있다.*/

#pragma endregion 반복자(이터레이터)

}