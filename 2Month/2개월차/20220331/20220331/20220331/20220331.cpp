// 20220331.cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.
//

#include "stdafx.h"


int main()
{
    return 0;
}

/*
일반화 프로그래밍 :  데이터 타입들을 가질 수 있는 
기술에 중점을 두어 재사용성을 높일 수 있는 프로그래밍 방식이다
매크로는 코드 복사만 하기 때문에 디버깅에 어려움이 있다.데이터 형식에 의존하지 않고, 하나의 값이 여러 다른


인라인 함수 : 컴파일 시점에 함수 호출위치에 바로 함수 코드를 삽입하는 형태의 함수
컴파일러가 최대 8 글자까지 인라인화 시킨다.

사실 인라인화를 컴파일러가 판단해서 하기 때문에 붙이든 안붙이든 크게 의미가 없다.

인라인함수는 매크로와 달리 자료형에 대해서 자유로울 수 없다.

인라인 함수는 선언과 몸체가 한꺼번에 묶어져 있어야 인라인화가 가능하다.

인라인 함수를 선언 했더라도 일반 함수로 바뀌는 경우
1. 인라인 함수를 함수 포인터로 활용할 때(함수포인터에 함수의주소를 넣어줘야하는데 인라인 함수는 메모리할당이 아니라 코드를 치환하는 것이기 때문에 메모리에 없다.
때문에 인라인함수를 포인터에 대입하는순간 인라인함수가 아니게 된다.)
2. 인라인 함수를 재귀 형태로 호출할 때(메모리상에 할당을 해야 재귀적으로 호출을 할 수 있다. 인라인함수로 재귀호출을 하면
몇번 호출하는지 알 수 없기 때문이다.)


*/

/*
연산자 오버로딩 : 연산자에 적용을 시킨 함수 오버로딩의 문법
1. 본래 연산자의 기능을 뒤바꿀순 없다.
2. 사용자 정의 자료형일 때 성립하는 문법이다. (클래스나 구조체)
3. 클래스 맴버로만 존재할 수 있는 연산자 =, (), [], ->, 좌측 기준으로만 연산을 수행하는 연산자들;
연산자오버로딩은 자주쓰진않으니 어떻게 쓰는지만 암기하고 가는게 좋다.
단항 연산자 오버로딩시 리턴타입을 원본으로 해줘야한다. 1번만 할 때는 산관없는데 여러번이용시 적용값이 누적돼야하기때문

함수 객체(funtor) : ()연산자 오버로딩을 통해 객체를 함수처럼 사용하는 문법

임시 객체 = 코드라인을 벗어나면 소멸되는 특성을 갖고 있다.

string 클래스 
문자열 비교 == (strcmp)  연산자오버로딩으로 구현해오기
문자열 결합 + (strcat)
문자열 대입 = (strcpy)


*/
