// 20220401.cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.
//

#include "stdafx.h"



void main(void)
{

	/*
	템플릿 : 틀, 함수 또는 클래스를 생성하기 위한 문법
	기능은 결정되어 있지만 자료형은 결정되어 있지 않은 상태

	함수 템플릿 : 함수의 모양으로 이뤄져서 함수를 생성하는 템플릿
	템플릿 함수 : 템플릿에 의해 생성된 함수
	클래스 템플릿
	tamplate<typename, class> 두가지가 있다. typename 과 class

	함수 템플릿의 예 ( 단항  템플릿)
	tamplate<typename T>
	T Add(T a, T b)
	{
		return a + b;
	}
	
	템플릿 함수
	Add<int>(1,2); //내부적으로 함수를 생성하고 호출한다. 함수를 생성하는게 인스턴스화다.
	템플릿의 단점 : 코드 비대화를 야기할 수 있다. 내부적으로 새로운 자료형이 들어올 때 마다 
	새로운 함수를 생성하기 때문에 비대화(크기가 커지다)될 수 있다.
	템플릿은 대부분 인라인화가 이루어지게 선언과정의를 한군데에 묶어서 한다.


	템플릿 특수화 : 특정 자료형에 해당하는 템플릿 동작을 따로 정의하는 문법
	조건 : 모든 자료형에 해당하는 템플릿이 우선 존재해야함
	template<>
	char* Add(char* a, char* b)
	{
		int iLength = strlen(a) + strlen(b);
	}
	
	특수화를 진행한 템플릿은 자료형이 명시되어 있기 때문에 함수 오버로딩 문법 또한 성립된다.


	이항템플릿
	두 개 이상의 타입을 갖는 템플릿

	tamplate<typename t1, typename t2, typename t3>
	t3 Add(Ta a, T2 b)
	{
		return a + b;
	}

	클래스 템플릿
	template<typename t>
	class CObj
	{
	private:
	t m_X;
	t m_Y;
	
	public:
	CObj() {}
	~CObj(t _x, t _y) : m_x(x), m_y(y);

	CObj<int> IntObj(10,20)
	CObj<float> FloatObj(30.f,20.f)

	템플릿은 해당 중괄호안에서만 가능하다.
	템플릿을 쓸 때 마다 템플릿자료형을 알려줘야하기 때문에 보통 선언과 몸체를 한군데에 묶어서 쓴다.

	템플릿 내에 선언한 static 변수는 같은 자료형의 템플릿인 경우에만 메모리를 공유한다.
	템플릿도 상속이 가능하다.

	템플릿의 장점
	1. 모든 자료형을 호환한다.
	2. 템플릿이 사용되는 형식은 컴파일 타임에 이뤄지기 때문에 오류가 발생하기 전에 컴파일러가 검사를 수행하여 안전하다
	3. 컴파일러가 함수 또는 클래스를 생성해주기 때문에 생성속도가 빠르다.

	템플릿의 단점
	1. 자료형의 개수가 많아질수록 일일이 생성하기 때문에 코드 비대화를 불러온다.
	2. 실행파일의 크기가 커진다.
	
	
	*/
  
}

