// 20220330.cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.
//

#include "stdafx.h"

	/*가상함수가 많아질수록 가상함수포인터가 증가하고
부모를 상속받을 때 쓸모없는 데이터가 많아진다.

오버라이딩 : 부모클래스의 포인터로 자식 클래스의 기능을 사용하게 하는 문법
오버라이딩의 특성 = 1. 은닉화 , 2. 재정의
버츄어가 붙으면 정적바인딩이 사용안된다.
가상함수이기 때문에 일반함수처럼 정적바인딩이 안된다.
은닉화 = 어떤 가상포인터의주소인지에 따라 동적인 타이밍에
결정되기 때문에 어떤 가상함수테이블을 참조하기때문에 결정권이 숨겨져있는것이다.
동적바인딩, 오버라이딩, 가상함수 작동원리
동적바인딩을 하기위해선 일반적으로 가상함수가 필요하다.
오버라이딩을 하려면 버츄얼을 통한 가상함수가 필요하다
가상함수의 동작원리는 버츄어키워드를 이용해 가상함수포인터로 동적인타이밍에 가상함수테이블에 접근하여 가상함수를 사용한다.
상속을 사용하는 주된목적 = 같은 자료형으로 관리하겠다.
오버라이딩 = 자료형은 부모꺼를 사용하지만 실질적인 메모리는 자식으로 사용하겠다.
오버라이딩 조건 = 1. 버츄어 키워드가 있어야한다 2. 부모클래스에 형태가 완전히 동일한 함수가 있어야한다.
순수가상함수 = 오버라이딩용도로만 사용하는 함수 선언후 = 0 으로 해준다.
순수가상함수가 단 하나라도 존재하는 클래스를 가리켜 추상 클래스라한다.
추상클래스는 객체 생성이 불가능하다.
객체 생성시 순수가상함수가 있다는건 알지만 몸체가 없기때문에 메모리에 할당이 불가능하다(함수의 필수조건을 충족을 안한다)
컴파일에게 랜더란함수가있는데 내 자식에서 만들어 놓을거야 허락해줘 몸체가없지만 자식에서 몸체를 만들거야
추상클래스가 존재하는것은 데이터를 제공하기위한것이고
추상클래스가 있으면 무조건 상속받는곳에서 정의해줘야한다.
오버라이딩할 때 지켜야하는 규칙
1. 순수가상함수가 단하나라도 있으면 추상클래스라고 부른다
2. 추상클래스는 객체생성이 불가능하다
3. 부모클래스에 선언한 순수가상함수가 있다면 모든 자식클래스는 반드시 몸체를 구현해야한다

공통적인 필수기능함수는 상속받기위해서 가상함수를 부모에서 구현해줘서 쓰면되고
자식에서만 필요한 기능함수는 순수가상함수로 만들어만주면되는데
근데 순수가상함수를 만들어도 결국 자식에서 또 정의해줘야하는건 똑같네

키워드 abstract = 추상클래스
override = 오버라이딩
더이상 상속받을게 없다 = final 키워드를 붙인다.
필수는 아니고 서로 팀플할 때 약속하고 써주면 알아보기 편하다.

가상소멸자
생성을 부모자료형으로 했으니 그 포인터를 삭제하면 자료형이부모이니 부모를 삭제하란걸로 인식한다.
때문에 부모소멸자에 virtual키워드를 붙여서 소멸자를 호출할 때 자식의 주소를 참조해서 호출할 수 있게해야한다.
만약 상속을 했다면(부모 클래스에 가상함수가 있다면) 부모클래스의 소멸자에는 버츄어 키워드를 붙이는게 좋다.
순수가상소멸자를 만들수는 있지만 깡통이더라도 몸체를 두는게 관리가 편할 수 있다.

오버로딩 : 함수이용할 때 사용하는 문법
정의 : 같은 클래스나 상속 관계에서 동일한 이름의 메소드 중복작성
관계 : 동일한 클래스 내 혹은 상속 관계
목적 : 이름이 같은 여럭개의 메소드를 중복 정의 하여 사용의 편리성 향상
조건 : 메소드 이름은 반드시 동일함, 메소드의 인자의 개수나 인자의 타입이 달라야 성립
바인딩 : 정적 바인딩, 컴파일 시에 중복된 메소드중 호출되는 메소드 결성

오버 라이딩 : 클래스를 상속 받을 때 사용하는 문법
정의 : 서브 클래스에서 슈퍼클래스에 있는 메소드와 동일한 이름의 메소드 재작성
관계 : 상속 관계
목적 : 슈퍼 클래스에 구현된 메소드를 무시하고 서브 클래스에서 새로운 기능의 메소드를 재정의하고자 함
조건 : 메소드의 이름, 인자의 타입, 인자의 개수, 인자의 리턴 타입등이 모두 같아야함
바인딩 : 동적 바인딩


가상함수테이블에 올라가는건 정적바인딩이나 함수를 호출하는건 동적바인딩이기때문에 동적바인딩으로 보는게 맞다.
은닉화 = 가상함수테이블의 소유권이 숨겨지기 때문에 은닉화가 성립된다

캐스팅 = c시절부터 존재했던 캐스팅(형 변환)
포인터 타입을 부모포인터가 아닌 자식포인터로 형변환 한게 다운캐스팅이다.

1. 캐스팅은 내부적인 동작 비용이 많이 발생하여 프로그램 전반의 속도를 저하시킨다.
2. c캐스팅은 무조건 형 변환을 허용하기 때문에 위험성이 다분이 높다. (자료형에따라 메모리의크기가 다를 수 있기 때문에)

RTTI
Run Time Type Information 런타임시에 객체 자료형에 관한 정보를 드러내는 C++ 매커니즘
간단한 정수나 문자같은 자료형 또는 제네릭(매크로)타입에 적용할 수 있다.
typeid

RTTI에 대해서 설명해보세요
캐스팅이 불가능한경우 nullptr을 반환하기 때문에 상대적으로 안전하다.
(모든 캐스팅은 불안전하다)

OOP
RTTI
CALL BACK 함수
3개가 중요하다

c++캐스팅연산자

<변환하고 싶은 자료형>(변환할 데이터)

static_cast<>() : 논리적인 형변환을 수행, 
우리가 늘 써오던 c스타일 캐스팅 형변환 시점이 컴파일 시점이기 때문에 static이란 명칭이 붙고 정적 캐스팅이라고 불린다.
int iNumber = static_cast<int>(3.14f);
c스타일에서는 상속이 아니여도 강제형변환이 가능하지만 static cast는 상속관계가 아니면 강제적인 형변환이 안된다.
static 캐스트는 상속의 유무를 확인한다.
객체 포인터는 부모자식을 판단할 수 없다. 때문에 단순 대입시 컴파일 에러가 발생한다.
자식타입을 부모형으로 형변환 해주는걸 다운캐스팅이라고 한다.

static_cast의 장점
1. 속도가 빠르다
2. 일반적으로 손쉽게 사용 (원시 데이터 캐스팅에도 사용 가능)

static_cast의 단점
1. 자식 객체 포인터에 부모 객체의 정보를 넣도록 허용하는 행위가 과연 코드적으로 논리적인지 의문이 생긴다.(위험한형변환)
2. 컴파일 시점인 정적 캐스팅에 해당하다 보니 런타임 시에 타입 체크를 하지 않아 위험한 형변환의 인지가 불가능하다


스테틱 캐스트와 다이나믹 캐스트의 차이점을 얘기해보세요


dynamic_cast<>() : 반드시 가상 함수를 하나 이상 포함한 상속관계일 때 다운캐스팅을 하기 위해 사용한다.
일반 자료형이나 일반 포인터는 사용할 수 없다.
안전하지 않은 캐스팅을 허용할 경우 nullptr 를 반환한다. 
안전한지 불안전한지 런타임시에 체크를 해주기 때문에 static_cast에 비하면 안전하다.(상대적으로 안전한거지 안전할수가없다)


const_cast<>() : 포인터가 참조하고 있는 원본 값 변경이 불가능할 때 
다른 포인터를 통한 원본 값 변경을 위해 일시적으로 const를 해제하기위해 사용
단, 포인터 또는 래퍼런스 형만 사용할 수 있다.

리인터프리트 캐스트
reinterpret_cast<>() : const 포인터를 제외한 모든 포인터의 형변환을 허용
심지어 비 논리적인 형 변환마저 허용
예측할 수 없는 결과를 초래하기 때문에 사용을 자제하는 편이다.
const를 제외한 모든 포인터의 형변환을 허용한다. 비논리적인것도 허용하기 때문에 문제가 다분히 일어날수있지만
void포인터형으로 예시를 한번 써봤다.





*/

int main()
{
    return 0;
}

