// 20220322.cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.
//

#include "stdafx.h"

#include "test.h"

int main()
{
	//void Initialize(void) // 초기화 해주는 함수
	//void Update(void) //매 프레임마다 갱신해주는 함수
	//void Release(void) // 
	//test t; // test = 클래스자료형 t = 인스턴스(주소) t가 클래스의 주소...
	//test* p = &t; //객체 = 클래스(자료형) + 인스턴스(주소)
	//cout << sizeof(t) << endl; // 참조할땐 t가 인스턴스의 주소를 갖고있고 주소의 값이니 
	//int* p = new int[5] p = int 5개의 데이터를 힙에 배열로 할당하고 그 주소를 보관하는 변수p의 0번지는 int1의 주소 p 0번지는 int2의 주소
	//클래스가 정의 될 때 메모리에 할당되지 않으며 객체가 생성될 때 메모리가 할당된다.
	/*int aArray[5] = { 1,3,5,7,9 };
	int* p = aArray;
	cout << *(p+4) << endl;

	p주소의 값이 인트값이고 p주소[2]번째는 인트를 보관하고있고
		인트는 당연히.이고
		이걸 클래스에 접목시켜보면
		class* p = new class[5];
	라고 가정하면 p = 힙공간에 class를 연속으로 할당한 배열의 대표주소 인거고
		p는 class의 주소 그러니 p->로 참조하는거고
		p[0] 0번째는 클래스니까 클래스는 값이고 그래서 인덱스로하면 p[0]. 으로 참조하는것
		본론으로 돌아가보자
		t는 주소랫어 주소인데 .으로 참조해 이게뭔 개소리야 근데 생각해보니까
		t의 주소는 있긴하겠지 근데 t는 클래스잖아 그럼 그냥 값인거고 그러니까 t.으로 참조하는거지
		결론은 객체는 클래스자료형의 값이다 대신 메모리에 할당해주기때문에 주소는 갖고있는거다.

		test t;
		test* pt = &t;
	*/




	//생성자 : 선언과 동시에 초기화 해주는 문법

//public:
//	CStudent(); // 생성자 : 객체가 생성되는 시점에 호출된다.
//	~CStudent(); // 소멸자 : 객체가 소멸되는 시점에 호출된다.
	/*
	객체가 생성될 때 내부적으로 자동생성되는 네 가지
	1. default 생성자, 2. default 복사 생성자, 3. default 대입 연산자, 4. 소멸자
	default 생성자는 프로그래머가 직접적으로 구현한 생성자가 단 한개라도 존재하면
	생성 , 호출되지 않는다.

	소멸자를 구현해주지 않을 경우 자동 default 소멸자가 호출된다.
	소멸자는 반드시 기본타입 하나 밖에 없다.(절대 오버로딩 불가능)

	객체의 생성과정은 다음과 같다.
	1. 메모리 할당 -> 2. 생성자 호출 ★★★ (객체가 생성되면 생성자가 무조건 호출된다)
	생성과 동시에 초기화는 아니나(메모리가 먼저 할당되기때문)
	그러나 객체를생성하면 생성자가 무조건 호출되기때문에 유효성을 갖게된다.
	이것때문에 선언과 동시에 초기화라고 봐도되지만 엄밀히 따지면 대입이다.
	생성자가 1개일 경우는 클래스내에서 선언과 동시에 초기화해도 괜찮지만
	생성자가 여러개일 경우 문제를 야기할 수 있다.
	여러개의 생성자
	오버로딩
	CStudent()
	CStudent(int _iSize)
	클래스 포인터를 malloc 이나 calloc으로 동적할당했을 때 생성자 호출이 안된다.★★
	c의 구조체는 맴버함수를 가질수없으나 c++ 구조체는 맴버함수를 가질수있다.
	중요한건 기본생성자냐 사용자가정의한 생성자이냐 이다.

	c시절에 동적할당한 메모리를 해제하는 함수 free는 객체의 소멸자를 호출할 수 없다.★★

	객체의 소멸과정
	1. 소멸자 호출 2. 메모리 반환





	

	*/

    return 0;
}

