20220322복습
생성자 : 객체를 생성과 동시에 초기화 해주는 함수
객체가 생성될 때 자동으로 호출되는 네 가지
1. default생성자 2. 소멸자 3. default 복사생성자 4. default 대입 연산자
default 생성자와 소멸자는 프로그래머가 직접적으로 구현한 생성자 또는 소멸자가 단 하나라도 존재하면 생성, 호출 되지 않는다.
생성자 = Func() / 소멸자 = ~Func()
생성자는 오버로딩이 가능하고 Func() , Func(int a)
소멸자는 오버로딩이 절대 불가능하다.
객체를 생성하는 과정 : 1. 메모리 할당 , 2. 생성자 호출 (객체가 생성되면 생성자가 무조건 호출된다)
객체가 소멸하는 과정 : 1. 소멸자 호출 , 2. 메모리 반환
생성과 동시에 초기화는 아니나(메모리가 먼저 할당되고 생성자를 호출하기 때문)
하지만 생성자를 호출해서 초기화를 진행하면 유효성을 갖기 때문에 선언과 동시에 초기화라는 개념으로 본다. 엄밀히 따지면 대입이다.
생성자가 1개일 경우는 클래스내에서 선언과 동시에 초기화를 해도 상관이 없지만,
생성자가 여러개일 경우 문제를 야기할 수 있다.
클래스 포인터를 c언어의 문법으로(malloc,calloc) 동적할당할 시 생성자 호출이 안된다. ★중요
클래스 포인터를 c시절의 문법으로(free) 메모리 해제 할 시 소멸자 호출이 안된다. ★중요
c의 구조체는 맴버함수를 가질수 없으나 c++의 구조체는 맴버함수를 가질 수 있다.
핵심은 기본 생성자냐 사용자가 정의한 생성자 이다.

클래스가 정의 될 때 메모리에 할당되지 않으며 객체가 생성될 때 메모리가 할당된다.

객체의 개념과 주소로참조하는지 값으로 참조하는지 헷갈리면 보자 ★★
=======================================================================

결론
객체 = 클래스(자료형) + 인스턴스(주소)
객체를 이용한 참조를 할땐 객체. 으로 참조한다. 왜냐하면 객체는 클래스 자료형인 값이기 때문
결국에 객체는 생성할 때 메모리에 할당해주고 할당할 때 주소를 부여받고 그 주소안에 객체의 값이 저장되는 것이다.
주소로 참조하려면 객체의 주소를 저장한후 객체의 주소 -> 로 하면된다.

int aArray[5] = { 1,3,5,7,9 };
	int* p = aArray;
	cout << *(p+4) << endl;

	p주소의 값이 인트값이고 p주소[2]번째는 인트를 보관하고있고
		인트는 당연히.이고
		이걸 클래스에 접목시켜보면
		class* p = new class[5];
	라고 가정하면 p = 힙공간에 class를 연속으로 할당한 배열의 대표주소 인거고
		p는 class의 주소 그러니 p->로 참조하는거고
		p[0] 0번째는 클래스니까 클래스는 값이고 그래서 인덱스로하면 p[0]. 으로 참조하는것
		본론으로 돌아가보자
		t는 주소랫어 주소인데 .으로 참조해 이게뭔 개소리야 근데 생각해보니까
		t의 주소는 있긴하겠지 근데 t는 클래스잖아 그럼 그냥 값인거고 그러니까 t.으로 참조하는거지
		결론은 객체는 클래스자료형의 값이다 대신 메모리에 할당해주기때문에 주소는 갖고있는거다.

	
