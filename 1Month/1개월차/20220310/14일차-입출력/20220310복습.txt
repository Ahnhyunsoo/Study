메모리함수
memset = 초기화를 해주는 메모리함수
원형 = memset(초기화할 변수의 대표주소 , 바이트단위로 초기화할 값, 초기화할 크기)
ex ) int iArray [5];
memset(iArray, 0, sizeof(iArray)); 

memcpy = 복사를 해주는 메모리함수
원형 = memcpy(복사할 변수의 대표주소, 복사할 원본의 대표주소, 복사할크기)
ex) int iArray[5];
    int iArray2[5];
memcpy(iArray,iArray2,sizeof(iArray));

memmove - 복사를 해주는 메모리함수 memcpy와 기능,원형 모두 동일함

memcpy , memmove의 차이점
1. memcpy는 바로 복사를 실행하고 memmove는 임시메모리를 생성해서 임시메모리에 복사를 한후 복사할 변수에 다시복사한다.
2. memcpy는 윈도우에서만 사용가능하고 memmove는 윈도우,리눅스 둘다에서 사용가능한 표준 스팩

입출력
스트림 : 장치들을 연결해주는 가상의 통로, 단 방향 스트림
버퍼 : 데이터들을 임시 저장하기 위한 메모리 블록

콘솔 표준 입출력
stdin = 표준 입력 스트림 
stdout = 표준 출력 스트림
stderr = 표준 에러 스트림

입출력에는 텍스트 모드 함수와 바이너리 모드 함수가 존재한다.
텍스트모드 함수는 문자열만 지원하며 바이너리모드 함수는 모든자료형 또는 사용자정의 자료형을 지원한다.
스트림을 지정할 수 있는 함수는 곧 핸들을 지정할 수 있는 함수를 의미하며, 핸들을 생성해주는 행동을 가리켜 파일을 개방하다 라고한다.

단일 문자 입출력
putchar = 단일 문자 출력 함수
fputc(stdout) 단일 문자 출력 함수

getchar = 단일 문자 입력 함수
fgetc(stdin) = 단일 문자 입력 함수

EOF = (end of file) 파일의 끝을 표현하기 위한 상수
입출력 함수의 반환값이 존재하는 이유 : char는 시스템에 따라서unsigned(음수)가 될 수도 있다. char가 음수가되면 eof를 표현할 수 없기때문에 
반환타입을 INT형으로 만들고 signed(양수)를 유지시켜 eof를 표현할 수 있게하려고 반환값을 두었다.
콘솔 입출력창에서 eof = ctrl + z 키이다.

문자열 입출력
puts = 문자열 출력함수 (자동으로 개행이 적용) 개행 = 한줄띄기 = endl
fputs = 문자열 출력함수

gets_s = 문자열 입력함수 (공백을 읽어들인다. 대신 엔터를 읽을순 없다. 사이즈가 초과되면 메모리 오류를 발생시킨다.
fgets = 문자열 입력함수 (엔터가 나올 때 까지 읽어들인다. 설정한 사이즈만큼 읽어온다. null문자를 고려한다.




