VIBuffer클래스를 만든다.
V = 버텍스를 의미하고
I = 인덱스를 의미한다.
어떤모델의 점을 찍을건지에따라 클래스를 정의할거다.
네모를 구성하기위한 점의 클래스
큐브를 구성하기위한 점의 클래스
그래서 VI_RECT, VI_CUBE등 모양에 따른 클래스를 만들고 이 클래스들의 부모클래스는 VIBuffer이다.
모든 정점들은 장치객체를 통해 처리되게 하기때문에 장치가 필요하고 컴포넌트가 장치가 필요하기 때문에 VIBuffer에서 장치를 받아와야한다.

자식클래스 Clone에서 pArg인자로넣는데 이게 미리 선언된 변수인가??

이 배열공간에 직접 접근해서 갱신할 때 빠른 속도로 갱신할 수 있게 한다. 이 때 인자로 DYNAMIC을 줘야한다.
락 언락을 자주할거면 DYNAMIC으로 해라. 대신 기초적인 랜더링 속도가 느려지는 단점이 있다.
이 공간의 값을 자주 갱신할 상황이 아니라면 DEFAULT로 주는게 좋다. 디폴트는 이 버퍼를 정적버퍼로 할당하는걸 의미한다.
fvf 너의 정점은 어떤 얘들을 갖고있는지 알려달라 
객체마다 정점의 구조체가 달라질 수 있기때문에 이 fvf도 자식에서 채워준다.
D3DFVF_XYZ로 주면 된다. D3DFVF_TEX1 = 인덱스가 아닌 갯수다. 이 구조체 안에는 텍스처벡터가 1개 있는 것이다. TEX0 = TEX가 없다는 것이다.
D3DFVF_TEXCOORDSIZE2(0) 0번 째 텍스처좌표는 float을 2개 가지고 있따는 것 이다. 즉 XY를 가지고 있다.
TEXCOORD를 따로 정의해주지 않아도 Default값이 2라서 상관없다.  
정점 구조체는 텍스처좌표를 8개까지 가질 수 있다.
마지막 인자의 MANAGED = 니가 알아서 메모리 관리해 라는 의미다.
이 함수는 즉 어떤 공간에 할당할건지 결정하기위한 함수인데 마지막 인자로 MANAGED를 넣어주면 알아서 관리하라는 의미다.
일반 RAM보다 VRAM이 훨신 빠르다.
쉐이더를 사용하면 행렬을 곱하는 연산을 CPU가 아닌 GPU가 한다. 그래픽카드에 있는 CPU가 한다.
이 작업만 생각해도 VRAM에 존재하는게 속도가 빠르다.
VRAM은 가상메모리 사용이 불가능하다.
MANAGE가 아니라 DEFAULT로 주면 무조건 그래픽카드로 간다. (VRAM)
하지만 VRAM으로 하지 않는다. 왜냐하면 VRAM은 너무 협소하다.
특정 정보들은 반드시 VRAM에 할당해야하는 정보들이 존재한다. 때문에 협소한 공간에서 꼭 저장해야할 객체들을 위해
DEFAULT가 아닌 MANAGE로 지정해준다.
MANAGE로 해주면 디바이스가 알아서 판단해서 VRAM이 비어있으면 VRAM에 저장하고 꽉차있으면 RAM에 저장한다.
마지막 인자로 LPDIRECT3DVERTEXBUFFER9을 넣어주면 된다.
이 공간을 대표하는 COM객체가 필요하다.
즉 이 함수는 LPDIRECT3DVERTEXBUFFER9 이라는 COM객체를 생성해주는 함수다. 때문에 마지막인자는 이중포인터로 넣는다. &
마지막 인자는 옛날거라 의미없으니 null로 처리한다.
이러면 정점공간을 만든 작업을 끝냈다.
이렇게 할당한 공간이 현재 쓰레기로 채워져있다. 그래서 이 공간을 채워주는 작업을 해야한다.

이렇게 공간을 채워줬으면
Lock과 Unlock을 걸어준다.
이공간에 직접 접근해서 이공간의 값을 바꾸려는것이다.
정적버퍼로 만들었으니 Lock Unlock속도가 겁나느리다. 하지만 로딩간에 이 버퍼를 생성하기때문에 상관없다.
정적버퍼로 만들면 생성은 느리지만 랜더링 속도가 빠르다.
동적버퍼는 생성은빠르지만 랜더링 속도가 느리다.
공간을 걸어잠구고 이 공간에 접근해서 값을 채우고 공간을 열고 나온다.
이 개념은 내가 들어가서 만들닫고 나오고 나서 다른놈들이 들어갈 수 있게 문들 열어두는거다.
스레드가 정점의 정보를 갱신하는도중에 참조하면 안되기때문에 접근못하게 잠궈두는거다.
Lock1인자 어디서부터 OffSet은 가장 앞쪽기준으로 어디부터 잠글까이다. 0으로주면 처음부터 잠구는거다.
2인자 어디까지 전체크기를 지정해준다. 0으로 주면 전체 사이즈라서 보통 0 0 으로 많이 준다.
3인자 정점배열의 가장 앞 주소를 받을 포인터이다.
보이드 포인터를 주는 이유 : 어떤 구조체인지 모르기 때문이다.
보이드포인터는 사용할 때 캐스팅 해줘야하는 번거로움이 있다.
void**이중 포인터는 오로지 void*만 담을 수 있다.
그래서 void**로 캐스팅 해줘야한다.
4인자는 락을 거는 형태인데 그냥 0준다.
여기서 채워주는 위치벡터는 로컬스페이스상의 위치벡터이다.

사이즈를 1로 잡아줘서 스케일을 배수이자 절대사이즈로 사용한다.

DX는 후면추려내기라는 나름의 최적화 기법을 사용하는데
이 후면추려내기는 킨다 끈다는 기능을 OnOff를 할 수 있다. 모델의 후면을 그릴지 안그릴지 결정한다.
정점이 시계방향으로 이루어질 땐 정면이고 반시계방향으로 이루어질 땐 후면이다.
그래서 모델을 바라봤을 때 후면이 그려지는것같지만 반시계반향이라 후면이 안그려지고 있는것이다.
상대적인 좌표라서 텍스처의UV좌표로 표현한다.
UV = 무조건 전체길이를 1로 본다 라는 개념이다. 이미지의 가장끝은 1,0이다.

정점배열에 값을 채워줬고 이 배열의 값을 통해서 그린다 라는 작업을 한다.
랜더한다는 기능은 모두 같기때문에 앵간하면 부모클래스에서 정의한다.

장치객체의 DrawPrimitive()를 호출해주면된다. 이 함수는 어떤 도형 / 어떤 형태를 그린다는 역할을 한다.
1인자 = D3DPRIMITIVETYPE 어떤 타입을 그릴지
2인자 = StartIndex 앵간하면 0
3인자 = PRIMITIVECOUNT 몇개의 도형을 그릴것인가 RECT = 2개

객체마다 다르기 때문에 부모에 PRIMITIVETYPE을 변수로 둔다.
자식에서 D3DPT_TRIANGLE 처럼 할당해주면 된다.
트라이앵글리스트는 정점버퍼에 들어가있는 점3개를 꺼내서 삼각형을 그린다는 것이다.
PRIMITIVECOUNT도 부모에 변수를 두고 자식에서 할당해준다.

DX함수는 명시적이지 않다. 보통 그린다는 기능을 하면 API에 비해서 명시적이지않다.
우선 그리고
어디에 그릴지 설정해주고
어떤걸 그릴지 설정해주고
어느부분을 그릴지 설정해주고
한마디로 이런 API때 인자로 받던걸 함수로 쪼개놨다.
DX함수의 특징은 한번 셋팅해놓으면 그 셋팅값이 유지된다.
즉 부분적이라도 최적화가 가능하면 중복코드가 줄어든다.

장치객체의 SetStreamSource() = 이후에 디바이스가 뭔가를 그린다면 이 그리기용함수가 사용해야할 리소스를 셋팅해주는 함수다.(버텍스버퍼)
1인자 : StreamNum 0번지로 셋팅 몇번 째 자원이냐 버텍스버퍼는 한번에 여러개의 버퍼를 사용할 수 있다. (3D에서 이팩트를 만들 때 이용한다.)
2인자 : 컴객체
3인자 : 0
4인자 : 정점하나의 버퍼크기 (미리만들어둔 변수)

장치객체의 SetFVF = 랜더링할 때 이 정점의 위치에 행렬을 곱해야한다. 그래서 이 정점이 어떻게 생겼는지 알려줘야한다.
1인자 : m_dwFVF

RECT의 원형을 만들고
컴포넌트에 복제해서
BackGround에게 추가한다.

얕은복사를해서 주소가 공유됐기 때문에 래퍼런스카운트를 증가시킨다.

CVIBuffer의 복사생성자에서 작업해주면 된다.

CMainApp에서 VIBuffer_Rect를 추가해줘서 원형을 만든다.

BackGround에게 이 원형을 모델로 추가해줄 생각이다.



