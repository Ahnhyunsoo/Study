기타에서 빈프로젝트 생성하고
새프로젝트에 Win32프로젝트 생성
바이너리폴더에는 2진화된 파일들을 저장한다.
클라이언트를 대표하는 파일 vcxproj
클라이언트에 딜리티를 누르면 제거된다. 그리고 다시 솔루션을우클릭해서 기존프로젝트추가해서 디폴트에있는 클라이언트를 추가해주면된다.
이제부턴 64비트로 사용한다.
구성은 디버깅으로하고 플랫폼을 64비트로 설정하면 그 속성에따라 빌드결과값이 달라진다.
구성속성 일반탭에 출력 디렉터리 = 생긴 파일들을 어디에 출력해줄것인가
출력디렉토리의 경로를 바이너리 폴더로 변경해주면된다.
파일경로는 클라이언트파일 기준이다. 클라이언트는 디폴트폴더에 있기때문에 ..해서 바이너리 폴더로 들어가서 거기에 저장해주면된다.
경로의 끝이 파일이면 폴더로 해도 괜찮지만 경로의 끝이 폴더면 꼭 역슬래시로 마무리 해줘야한다.

ㅡㅡ
빌드를 돌리면 바이너리 폴더에 파일을 저장하게 경로를 잡아준다.

헤더는 퍼블릭폴더에 cpp는 Private에 보관하겠다.
클래스 생성할 때 파일에서 파일명앞에 경로를 적어주면 그 경로에 파일이 저장된다.

도구에서 설정 가져오기 및 내보내기 다음누르고 비쥬얼 C++로 설정을 변경해라.
최상단에 생성자 솜려자
최하단에 생성관련함수 삭제관련함수
중간에 퍼블릭 변수 함수, 프로텍트 변수 함수, 프라이빗 변수, 함수
객체안에 모든 변수를 Private로 두고 가능한 Get Set을 자제하고 객체안에 함수를 구현해서 개발하면
코드의 중복이 줄고 함수의 재사용성이 늘어난다. 이런건 클래스의 모듈화라고 한다.
클래스는 함수의 기능구현을 위해 만드는것이다.
기능을 묶어두는것 = 클래스
데이터를 묶어두는것 = 구조체

생성자를 private로 두는 이유는 객체를 만들 때 크리에이트를 거쳐서 사용하게 만든다.
소멸자를 private로 제한두는 이유는 포인터변수를 갖고있을 때 포인터변수의 원본이 지워지면 안되는데 지울 수도 있기 때문이다.

클래스 = 정의
객체 = 메모리 덩어리

레퍼런스 카운트란 참조갯수
객체를 다른객체에서 포인터변수로 참조될 때 래퍼런스카운트를 1증가시킨다.
이 때 플레이어의 래퍼런스카운트를 변수로 둔다.
참조하고있는 객체가 삭제될 때 플레이어를 타고들어와서 래퍼런스카운트가 0이아니면 삭제를 안하고 래퍼런스카운트를 1 감소시킨다.

모든 클래스들의 부모가되는 슈퍼클래스를 만든다.
이 슈퍼클래스에 래퍼런스카운트변수와 삭제한다 검사한다 등의 함수를 만든다.
최상위 클래스로 CBase클래스를 만든다.

디바이스는 최상위 부모클래스인 IUNKOWN에서 래퍼런스 카운트를 관리해주기때문에 컴객체를 삭제할 때 릴리즈를 사용한다.

릴리즈는 릴리즈를 실행하기전에 래퍼런스카운트를 리턴해준다.

= defalut {} 를 의미한다. 생성자와 소멸자에서만 사용가능하다.
이렇게 해두면 cpp에서 생성자 소멸자의 몸체를 구현하지않아도된다.

싱글톤은 객체화를 1번한다.
싱글톤 또한 주소의 공유가 일어나기때문에 래퍼런스카운트가 필요하다.

내일 엔진프로젝트라는 또다른 프로젝트를만든다.
클라이언트에서 엔진프로젝트에서 구현해놓은 기능을 가져와서 쓸것이다.













