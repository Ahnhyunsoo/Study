베이스클래스는 모든 클래스의 부모가 되는 클래스이다.
이부모클래스의 핵심적인 기능은 래퍼런스 카운트를 관리하는 것 이다.
에드래퍼런스는 증가시키고 난 이후의 값을 리턴한다.
릴리즈는 값을 증가시키기 이전의 값을 리턴한다.
릴리즈의 감소시키고 난 이후의 값을 리턴한다. 릴리즈를 호출하면 리턴값이 0일 때 지워졌는지 감소시킨건지 판별할 수 없다.
릴리즈는 감소하기이전의 값이기 때문에 리턴값이 0이면 무조건 삭제라고 판별할 수 있고, 리턴값이0이상이면 감소라고 판별할 수 있다.
이 디스포인터는 오로지 모든맴버함수는 반드시 객체로부터 호출돼야한다.
스테틱맴버함수는 디스포인터를 사용할 수 없다. 객체로부터 호출된 것이 아니기 때문에 전역함수는 디스포인터를 사용할 수 없다.
delete this를 하면 부른 객체자신을 지워준다. 플레이어에서 릴리즈를 호출하면 플레이어를 지우고 몬스터에서 호출하면 몬스터를 지운다.
자식 소멸자를 호출하면 다  처리한 후 부모 소멸자또한 호출한다.

추상클래스는 객체를 만들 수 없다.

순수가상함수는 자식클래스에서 반드시 몸체를 구현해줘야 한다.
자식에서 프리를 해준후 부모의 프리를 호출해줘야한다.

소멸자를 사용하면 삭제 순서를 바꿀 수 없다. 무조건 최하위 소멸자 호출 후 부모소멸자를 호출하기 때문이다.
하지만 프리함수를 사용하면 삭제 순서를 변경할 수 있다. 자식프리를 삭제하기전에 부모프리함수를 먼저 호출하면 순서를 변경할 수 있다.

클라이언트프로젝트는 윈도우프로젝트로 제작하고 목적은 이미지를 띄우고 게임을 실행시키기위한프로젝트

엔진프로젝트는 클라이언트프로젝트에서 자주 사용할만한 기능들을 엔진프로젝트에 모아두는것
엔진프로젝트는 라이브러리제작프로젝트로 만들고 자주 사용하는 기능을 엔진프로젝트에 추가한다음 엔진프로젝트를 빌드하면
exe를 만들지 않고 lib라는 라이브러리라는 파일을 만들어준다.
하나의 클라이언트뿐만아니라 다른 클라이언트를 만들더라도 공통적으로 필요한 기능들을 만드는것이다. 예를들어 ObjMgr같은 기능들

사실 지금 제작하는 엔진은 크게 쓸모가 없지만 한번쯤 해보면 좋기 때문에 라이브러리 제작은 하는게 좋다.

베이스클래스는 어느프로젝트에서나 필요할법 하기 때문에 이 베이스클래스의기능을 엔진프로젝트로 빼서 구현한다.

필터를 하나다 생성해서 01 Engine이라고 추가하고 Win32프로젝트에서 DLL파일로 (빈프로젝트)만든다.

이 엔진프로젝트에 베이스 클래스를 추가한다. 클라이언트에 있는 헤더와 cpp를 엔진에 폴더에 옮긴다.
엔진폴더에 드래그앤드랍이로 헤더cpp넣어주고 클라이언트에 있는 헤더와 cpp는 제거해준다.
stdafx헤더도 지워준다.
디버그뿐만아니라 릴리즈또한 출력디렉토리를 설정해준다, 모든구성으로 설정해도된다.

특정클래스를 라이브러리화 시킨다고 지정해줘야한다.

class와 클래스명사이에 _declspec(dllexport)를 적어줘야한다. 

이렇게 생성된 라이브러리 파일 안에는 지정해준 헤더의 cpp몸체의 코드가 들어가있다.

경로를 ../../Engine/Base.h 라고 지정해줘야한다. 하지만 이러면 너무 불편하기때문에 이런식으로 설정안한다.

엔진프로젝트에서 클라이언트한테 알려줘야할 특정파일들을 래퍼런스폴더에 헤더스랑 라이브러리폴더를 생성해서 여기다가
엔진에서 제작한 헤더파일과 라이브러리 폴더들을 들을 여기다가 모아둔다.

클라이언트 우클릭 C/C++에서 일반탭에 추가포함 디렉터리 ../../Reference/Headers/ 추가하고
라이브러리는 링커에 일반탭을 누르면 추가 라이브러리 디렉터리가 있다. 여기다가 ../../Reference/Librarys/ 를 추가해주면 된다.

이렇게 헤더와 라이브러리를 참조용으로 공유해주는 이유는 cpp를 직접 수정할 수 없기때문에 이런식으로 참조하게 만들어준다.

라이브러리 추가는 링커에 입력 탭에다가 추가종속성에서 Engine.Library를 추가해주면 된다.

클라이언트한테 라이브러리로 가져온 클래스헤더라고 알려줘야 오류가 안난다. 이렇게 안해주면 cpp를 찾기 때문이다.

래퍼런스에 헤더스를 열어서 export가 아니라 import로 수정해주면 된다. 이렇게 알려주면 외부에서 가져온 클래스라고 알수있다.

이렇게 작업해주면 함수 구현부를 cpp가 아니라 라이브러리에서 검색하게 해준다.

메인앱에 크리에이트 함수를 만들고 그 안에서 객체를 생성후 동적할당 해주고 구현해놓은 이니셜라이즈함수를 호출하게 작성해준다.

메인앱 헤더를 추가하려면 경로를 ../Public/MainApp.h 라고 해줘야한다.

DLL = 동적 링크 라이브러리 Dynamic Link Library

파일을 정적링크라이브러리로 만들면 라이브러리만 만들어진다. 클래스의 구현부만 제작된다.

동적링크 라이브러리는 원래 라이브러리에 들어갔어야할 함수 구현부를 DLL파일에 담는다. 그리고 라이브러리파일또한 만든다.
이 라이브러리파일에는 클래스의 맴버함수를 호출했을 때 그 구현부를 담고있는 DLL파일의 링크를 담고있다.
정적라이브러리 파일은 그자체가 코드고 동적라이브러리는 그코드에 접근할수있는 링크를 담고있다.

추가 종속성이란 EXE에 라이브러리구현부코드 또한 포함하면 exe파일에 그 라이브러리 함수구현부가 포함된다.

정적라이브러리는 코드그 자체기때문에 exe파일이 크기가 커지지만 동적라이브러리파일은 링크만 있기때문에 상댖거으로 가벼워진다.

DLL을 바꾸면 엔진프로젝트만 빌드돌리면된다. exe를 바꾼다는건 모든 전체코드를 다시 빌드해야한다.

정적라이브러리의 장점은 코드자체가 있기때문에 빠른접근이 가능하다는 접근이 있다.

이 DLL을 exe가 있는 위치로 옮겨주면 된다. exe파일안에 라이브러리 파일이 포함되어 있기 때문이다.

수정하면 dll과 라이브러리를 빌드후에 새로만들어진 파일들로 갱신해줘야한다.

엔진 디파인을 만들어서 매크로를 만들어준다.

엔진프로젝트의 속성을 열면 C/C++탭에 전처리기가 있다.

전처리기 정의에 보면 엔진프로젝트에는 ENGINE EXPORT가 있고 클라이언트에는 없다.

이걸통해서 이게 정의됐는지 안됐는지를 통해서 매크로를 제작하면 된다.

헤더를 수정하면 퍼블릭에 헤더를 복사해서 래퍼런스 헤더스에 갱신해줘야한다.

프레임워크에 새로만들기 UpdateLib.bat라는 메모장을 하나 새로 만든다.

비쥬얼스튜디오에서 열어서 콘솔 명령어를 입력해주면 이배치파일을 실행하면 자동으로 복사붙여넣기를 수행해준다.

xcopy /옵션 .복사할 파일이 있는 경로 	.복사받을경로

xcopy .\Engine\Public\*.h 		.\Reference\Headers\
라이브러리랑
DLL파일또한 똑같이 작업해줘야한다.

/y    = 같은 파일이 존재할경우 덮어쓴다는 옵션

배치파일을 통해서 편하게 자동작업을 해줄수있다.