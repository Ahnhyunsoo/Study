Enum Struct같은 헤더 작성하고 디바이스 초기화에 대해 얘기해보겠다.

WINCX WINCY나 핸들같은 헤더들은 클라이언트에서 사용하기 때문에 클라이언트디파인과 엔진디파인을 나눈다.

기존에 쓰던 디파인헤더들을 엔진 퍼블릭 헤더스에 옮겨놓는다.

엔진에다가 엔진디파인말고 퍼블릭폴더에다가 Engine_Macro.h를 생성해서 기존에디파인헤더에 있던 메세지박스와 
싱글톤 매크로와 엔진디파인에 있던 익스포트매크로또한 매크로에 옮기고 엔진디파인에 매크로헤더를 포함해준다.

앞으로 클래스는 항상 네임스페이스를 지정해서 구현한다.
같은 이름의 클래스가 있을 수도있기때문에 이걸 네임스페이스로 구현해준다. 어디구역에 어느클래스로 구별한다.

매크로에 네임스페이스 매크로를 비긴 엔드로 추가해서 네임스페이스이름을 인자로 주면 된다.

스코프연산자를 일일이 써주면 번거롭기때문에 using namespace Engine;을 사용하면 된다.
스트럭트헤더에 namespace Engine을 잡아주면 문제가 안된다. 매크로는 전처리기여서 네임스페이스가 의미없다.
엔진디파인에 유징네임스페이를 포함해주면 더 편하다.

마찬가지로 클라이언트 퍼블릭폴더에 Client_Defines.h를 생성하고
namespace Client를 잡아주고 using namespace Client를 해준다.

Enum은 지운다.

엔진에 Engine_Function, Engint_Functor를 생성한다.

Function에 Safe_AddRef생성해준다. 객체가 Null이 아닐 때만 AddRef카운트를 증가시켜준다.
엔진디파인이 기존의 인쿨루드와 비슷한역할을한다. 헤더들을 전부 포함하고 using namespace까지 해준다.
헤더내에서는 헤더에 있는 매크로들을 사용하지 않는게 좋다. 순서가 바뀌면 오류가 날 수 있기때문이다.

Typedef헤더를 생성해서 각종 자료형들의 이름을 쓰기편하게 재정의해준다.

나중에 유지보수관련해서 Typedef으로 관리하면 헤더만 바꾸면 전부 적용되기때문에 이런식으로 관리하는게 좋다.

d3d9.h는 윈도우sdk에 포함되어있기 때문에 따로 경로를 안잡아도 인클루드가 가능하다.

d3dx9는 경로를 직접 잡아줘야한다.

d3dx9을 포함하지 않는 이유는 너무많은 기능이 있기 때문에 이걸 포함하면 실행파일의 크기가 너무 커지기 때문이다.

그래서 마이크로소프트가 이 d3dx를 세분화해서 기능을 나눠놨기 때문에 필요한 기능을 인클루드해서 사용하면된다. 번거롭지만 파일이 가벼워진다.

엔진 우클릭 포함디렉터리에서 인클루드

라이브러리 디렉터리에서 x64에서 포함

정상적으로 d3dx9을 사용하려면 using namespace std가 필요하다.

구조체를 선언과 동시에 타입디파인해주고 상속을 받으면
부모에있는 기능을 포함하여 내가 필요한기능을 더 추가적으로 구현할수잇다.

클라이언트또한 엔진에 인클루드를 포함하기때문에 d3dx9을 포함하는데 경로가 지정이안돼있기때문에
포함디렉터리랑 라이브러리디렉터리를 잡아줘야한다.

그래픽 디바이스

기존 디바이스를 엔진 헤더에 옮겨놓고 Graphic_Device로 수정해준다.
Cpp는 엔진 private에 옮겨준다.

Device클래스또한 네임스페이스 잡아주고 CBase를 상속받게 지정해주면된다.

추가포함디렉터리에 ../Public/을 잡아주면 경로를 따로 안잡아줘도 사용할수있다.

기존 Release를 Free로 옮기면된다.

InitDevice에서 핸들과 창크기 창모드등을 인자로 받는다.

추가종속성에 library 포함해줘야한다.

클라이언트헤더에서 핸들 선언하고 변수에 핸들을 선언해줘야한다.

Tick = Update함수

루프에서 타임델타를 받아와서 인자로 넘겨주면서 전파하는식으로 구현한다.
이렇게되면 모든객체들이 같은값을 사용하기때문에 비교적 안전하다.

깊이버퍼
여기서의 원근감이란 가까이 있는얘가 멀리잇는얘가 덮인다는 개념이다.

버퍼란 메모리공간
48만개의 백버퍼를 만들고
뎁스버퍼라는 48만개의 버퍼를 만든다.

dx는 기록하기전에 if(테스트)를 한다. 조건을 만족할 때만 백버퍼에 픽셀을 할당한다. 이 테스트가 깊이테스트다.
dx는 그리는순서를 상관안써도 깊이테스트로 인해서 랜더되는결과가 결정된다.

이 보여지는 화면에서 가장가까운 깊이버퍼의 깊이는0 가장먼 깊이버퍼의 깊이는 1
가까운게0 멀리있는게 1

깊이테스트를 반드시 수행하기 때문에 랜더순서를 상관안써도된다.

그리려고 하는 위치에 있는 깊이값과 비교를해서 깊이값이 더 작으면 그려준다.

같을경우엔 보통 덮어쓴다. 이 같은걸 zFighting이라고하고 이럴땐 가려질놈의 깊이버퍼를 조금씩 땡기면된다.

